/**
 * @className CaseFrame.java
 * 
 * @ClassDescription Case Frames are the highlight of the semantics in SNePS as they define sets
 * 	of relations to be used together to give a precise meaning and define the semantic class for 
 *  the nodes based on the case frame implemented by the nodes. In the current implementation
 *  (version) of Java SNePS, the case frame is implemented as a 5-tuple (semanticClass, relations, 
 *  aignatureIDs, signatures and id).  
 * 
 * @author Nourhan Zakaria
 * @version 2.00 18/6/2014
 */
package sneps;

import java.util.Collections;
import java.util.Hashtable;
import java.util.LinkedList;

public class CaseFrame {
	public static CaseFrame andRule, orRule, andOrRule, threshRule,
			numericalRule;

	/**
	 * The name of the semantic class that represents the default semantic type
	 * of any node with a down-cable set implementing this case frame.
	 */
	private String semanticClass;

	/**
	 * The relations included in the current case frame along with their
	 * adjustability and limit constraints within this case frame.
	 */
	private Hashtable<String, RCFP> relations;

	/**
	 * A list of strings representing the IDs of the case frame signatures
	 * included in the current case frame. The main aim of this is to enforce
	 * priority while checking the case frame signatures during the process of
	 * building a node.
	 */
	private LinkedList<String> signatureIDs;

	/**
	 * The case frame signatures included in the current case frame. A case
	 * frame can have more than one signature and thus the signatures are
	 * prioritized.
	 */
	private Hashtable<String, CFSignature> signatures;

	/**
	 * A string id that is automatically generated by concatenating all names of
	 * the relations included in the case frame separated by commas after
	 * sorting them according to their lexicographical order. Each case frame
	 * has a unique set of relations and that is why the string id composed of
	 * the relations included in the case frame will be unique for each case
	 * frame.
	 */
	private String id;

	// TODO add optional name field (can be null)

	/**
	 * The constructor of this class.
	 * 
	 * @param semantic
	 *            the name of the semantic class representing the semantic type
	 *            specified by the current case frame.
	 * @param r
	 *            a linked list of RCFP (Relation case frame properties) for all
	 *            the relations included in the current case frame.
	 */
	public CaseFrame(String semantic, LinkedList<RCFP> r) {
		this.semanticClass = semantic;
		this.relations = generateRCFPHashtable(r);
		this.id = createId(r);
		this.signatureIDs = new LinkedList<String>();
		this.signatures = new Hashtable<String, CFSignature>();
	}

	/**
	 * This method is invoked by the constructor to generate the hash table of
	 * relations (RCFP) from the linked list of relations (RCFP) that was passed
	 * to the constructor as a parameter. Each entry in the hash table generated
	 * has the relation name as the key and the RCFP of the corresponding
	 * relation as the value.
	 * 
	 * @param r
	 *            a linked list of RCFP representing the relations included in
	 *            the current case frame.
	 * 
	 * @return the hash table of the relations. (Each entry has the relation
	 *         name as the key and the RCFP of the corresponding relation as the
	 *         value).
	 */
	private Hashtable<String, RCFP> generateRCFPHashtable(LinkedList<RCFP> r) {
		Hashtable<String, RCFP> relations = new Hashtable<String, RCFP>();
		for (int i = 0; i < r.size(); i++) {
			relations.put(r.get(i).getRelation().getName(), r.get(i));
		}
		return relations;
	}

	/**
	 * Adds a new signature to the current case frame.
	 * 
	 * @param sig
	 *            the case frame signature that will be added.
	 * @param priority
	 *            the priority of the new case frame signature.
	 * 
	 * @return true if the case frame signature was added successfully, and
	 *         false otherwise. (The same case frame signature (same id) cannot
	 *         be added twice).
	 */
	public boolean addSignature(CFSignature sig, Integer priority) {
		if (!this.signatures.containsKey(sig.getId())) {
			if (priority == null) {
				this.signatureIDs.add(sig.getId());
			} else {
				this.signatureIDs.add(priority.intValue(), sig.getId());
			}
			this.signatures.put(sig.getId(), sig);
			return true;
		}
		return false;
	}

	/**
	 * Removes a case frame signature by its ID.
	 * 
	 * @param id
	 *            the id of the case frame signature that will be removed.
	 * 
	 * @return true if the case frame signature was removed successfully, and
	 *         false otherwise.
	 */
	public boolean removeSignature(String id) {
		if (this.signatures.containsKey(id)) {
			this.signatures.remove(id);
			for (int i = 0; i < this.signatureIDs.size(); i++) {
				if (this.signatureIDs.get(i).equals(id)) {
					this.signatureIDs.remove(i);
					return true;
				}
			}
		}
		return false;
	}

	/**
	 * Removes a case frame signature.
	 * 
	 * @param sig
	 *            the case frame signature that will be removed.
	 * 
	 * @return true if the case frame signature was removed successfully, and
	 *         false otherwise.
	 */
	public boolean removeSignature(CFSignature sig) {
		if (this.signatures.containsKey(sig.getId())) {
			this.signatures.remove(sig.getId());
			for (int i = 0; i < this.signatureIDs.size(); i++) {
				if (this.signatureIDs.get(i).equals(sig.getId())) {
					this.signatureIDs.remove(i);
					return true;
				}
			}
		}
		return false;
	}

	/**
	 * 
	 * @return the linked list that contains the IDs of the case frame
	 *         signatures ordered according to their priority.
	 */
	public LinkedList<String> getSignatureIDs() {
		return this.signatureIDs;
	}

	/**
	 * 
	 * @return the hash table that contains the case frame signatures.
	 */
	public Hashtable<String, CFSignature> getSignatures() {
		return this.signatures;
	}

	/**
	 * A method that is invoked by the constructor to create the ID of the newly
	 * created case frame.
	 * 
	 * @param r
	 *            a linked list of RCFP (Relation case frame properties) for all
	 *            the relations included in the current case frame.
	 * 
	 * @return the ID of the newly created case frame.
	 */
	private String createId(LinkedList<RCFP> r) {
		String id = "";
		LinkedList<String> relationNames = new LinkedList<String>();
		for (int i = 0; i < r.size(); i++) {
			relationNames.add(r.get(i).getRelation().getName());
		}
		Collections.sort(relationNames);
		for (int i = 0; i < relationNames.size(); i++) {
			if (i == 0) {
				id = id.concat(relationNames.get(i));
			} else {
				id = id.concat(",").concat(relationNames.get(i));
			}
		}
		return id;
	}

	/**
	 * 
	 * @return the name of the default semantic class specified by the current
	 *         case frame.
	 */
	public String getSemanticClass() {
		return this.semanticClass;
	}

	/**
	 * 
	 * @return the hash table that contains the relation names of all the
	 *         relations included in the case frame along with their
	 *         corresponding RCFP.
	 */
	public Hashtable<String, RCFP> getRelations() {
		return this.relations;
	}

	/**
	 * 
	 * @return the ID of the case frame.
	 */
	public String getId() {
		return this.id;
	}

	/**
	 * 
	 * @param relation
	 *            the relation that its corresponding RCFP is needed.
	 * 
	 * @return the RCFP of the given relation and null if the relation is not
	 *         included in the current case frame.
	 */
	public RCFP getRelation(Relation relation) {
		if (this.relations.containsKey(relation.getName())) {
			return this.relations.get(relation.getName());
		}
		return null;
	}

	public static void createRuleCaseFrame() throws CustomException {
		if (RCFP.andAnt == null)
			RCFP.createRuleProperties();
		LinkedList<RCFP> and = new LinkedList<RCFP>();
		and.add(RCFP.andAnt);
		and.add(RCFP.cq);
		andRule = Network.defineCaseFrame("Proposition", and);
		
		LinkedList<RCFP> or = new LinkedList<RCFP>();
		or.add(RCFP.ant);
		or.add(RCFP.cq);
		orRule = Network.defineCaseFrame("Proposition", or);
		
		LinkedList<RCFP> andOr = new LinkedList<RCFP>();
		andOr.add(RCFP.arg);
		andOr.add(RCFP.max);
		andOr.add(RCFP.min);
		andOrRule = Network.defineCaseFrame("Proposition", andOr);
		
		LinkedList<RCFP> thresh = new LinkedList<RCFP>();
		thresh.add(RCFP.arg);
		thresh.add(RCFP.threshMax);
		thresh.add(RCFP.thresh);
		threshRule = Network.defineCaseFrame("Proposition", thresh);
		
		LinkedList<RCFP> numerical = new LinkedList<RCFP>();
		numerical.add(RCFP.andAnt);
		numerical.add(RCFP.cq);
		numerical.add(RCFP.i);
		numericalRule = Network.defineCaseFrame("Proposition", numerical);
	}
}